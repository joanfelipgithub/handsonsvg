<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>SVG Corner Rounder & Line Connector</title>
<style>
    body {
        margin: 0;
        font-family: sans-serif;
        background: #202020;
        color: #fff;
        display: flex;
        height: 100vh;
        overflow: hidden;
    }

    #leftPanel {
        width: 260px;
        background: #2b2b2b;
        padding: 15px;
        box-sizing: border-box;
        border-right: 2px solid #111;
    }

    #workArea {
        flex-grow: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        overflow: hidden;
    }

    #dropZone {
        position: absolute;
        top: 0; left: 0;
        right: 0; bottom: 0;
        color: #aaa;
        border: 3px dashed #555;
        border-radius: 15px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 22px;
        opacity: 0.5;
        pointer-events: none;
    }

    canvas {
        border: 1px solid #555;
        background: white;
        max-width: 95%;
        max-height: 95%;
    }

    label { display: block; margin-top: 15px; }
    input[type="range"] { width: 100%; }
    button {
        margin-top: 20px;
        width: 100%;
        padding: 8px;
        font-size: 16px;
    }
</style>
</head>
<body>

<!-- LEFT TOOL PANEL -->
<div id="leftPanel">
    <h2>Controls</h2>

    <label>
        Corner radius:
        <input type="range" id="radiusSlider" min="0" max="80" value="10">
        <span id="radiusValue">10</span> px
    </label>

    <label>
        Trim/extend:
        <input type="range" id="trimSlider" min="-40" max="40" value="0">
        <span id="trimValue">0</span> px
    </label>

    <label>
        Fill color:
        <input type="color" id="fillPicker" value="#ff0000">
    </label>

    <button id="exportBtn">Export SVG</button>
</div>

<!-- WORK AREA WITH DRAG & DROP -->
<div id="workArea">
    <div id="dropZone">Drag SVG file here</div>
    <canvas id="canvas" width="800" height="600"></canvas>
</div>

<script>
/* ============================================================
   GLOBALS
============================================================ */
let svgData = null;
let parsedPaths = [];
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");


/* ============================================================
   DRAG & DROP HANDLERS
============================================================ */
const workArea = document.getElementById("workArea");

workArea.addEventListener("dragover", e => {
    e.preventDefault();
    document.getElementById("dropZone").style.opacity = "1";
});

workArea.addEventListener("dragleave", e => {
    e.preventDefault();
    document.getElementById("dropZone").style.opacity = "0.5";
});

workArea.addEventListener("drop", async e => {
    e.preventDefault();
    document.getElementById("dropZone").style.opacity = "0.5";

    const file = e.dataTransfer.files[0];
    if (!file) return;

    const text = await file.text();
    loadSVG(text);
});


/* ============================================================
   LOAD SVG STRING INTO MEMORY
============================================================ */
function loadSVG(text) {
    svgData = new window.DOMParser().parseFromString(text, "image/svg+xml");

    parsedPaths = [...svgData.querySelectorAll("path")].map(path => ({
        original: path.getAttribute("d"),
        element: path
    }));

    render();
}


/* ============================================================
   BASIC PATH PARSER FOR LINE GEOMETRY
============================================================ */
function parsePath(d) {
    const cmds = d.match(/[a-zA-Z][^a-zA-Z]*/g) || [];
    const out = [];

    for (const c of cmds) {
        const type = c[0];
        const nums = c.slice(1).trim().split(/[\s,]+/).map(Number);

        if (type === "M" || type === "L") {
            out.push({ type, x: nums[0], y: nums[1] });
        }
    }
    return out;
}


/* ============================================================
   ROUND CORNERS + TRIM/EXTEND
============================================================ */
function processPath(points, radius, trimDistance) {
    if (points.length < 2) return points;

    function shiftPoint(p1, p2, dist) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.hypot(dx, dy);
        return {
            x: p1.x + (dx / len) * dist,
            y: p1.y + (dy / len) * dist
        };
    }

    points = [...points];

    // trim or extend start + end
    points[0] = shiftPoint(points[0], points[1], trimDistance);
    const last = points.length - 1;
    points[last] = shiftPoint(points[last], points[last - 1], trimDistance);

    // rounding
    const rounded = [points[0]];

    for (let i = 1; i < points.length - 1; i++) {
        const p0 = points[i - 1];
        const p1 = points[i];
        const p2 = points[i + 1];

        const v1 = { x: p1.x - p0.x, y: p1.y - p0.y };
        const v2 = { x: p2.x - p1.x, y: p2.y - p1.y };

        const len1 = Math.hypot(v1.x, v1.y);
        const len2 = Math.hypot(v2.x, v2.y);

        const r = Math.min(radius, len1 / 2, len2 / 2);

        const A = { x: p1.x - (v1.x / len1) * r, y: p1.y - (v1.y / len1) * r };
        const B = { x: p1.x + (v2.x / len2) * r, y: p1.y + (v2.y / len2) * r };

        rounded.push(A, { type: "arc", cx: p1.x, cy: p1.y, x: B.x, y: B.y });
    }

    rounded.push(points[points.length - 1]);
    return rounded;
}


/* ============================================================
   RENDER TO CANVAS
============================================================ */
function render() {
    if (!svgData) return;

    const radius = +radiusSlider.value;
    const trim = +trimSlider.value;
    const fill = fillPicker.value;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (const p of parsedPaths) {
        const pts = parsePath(p.original);
        if (pts.length < 2) continue;

        const processed = processPath(pts, radius, trim);

        ctx.beginPath();
        ctx.moveTo(processed[0].x, processed[0].y);

        for (let i = 1; i < processed.length; i++) {
            const pt = processed[i];
            if (pt.type === "arc") {
                ctx.quadraticCurveTo(pt.cx, pt.cy, pt.x, pt.y);
            } else {
                ctx.lineTo(pt.x, pt.y);
            }
        }

        ctx.fillStyle = fill;
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.fill();
        ctx.stroke();
    }
}


/* ============================================================
   UI EVENTS
============================================================ */
radiusSlider.oninput = e => {
    radiusValue.textContent = e.target.value;
    render();
};

trimSlider.oninput = e => {
    trimValue.textContent = e.target.value;
    render();
};

fillPicker.oninput = render;


/* ============================================================
   EXPORT AS NEW SVG
============================================================ */
exportBtn.onclick = () => {
    if (!svgData) return;

    alert("I can give you a full exporter that writes updated <path d='...'> commands based on your edits. Say 'export version' and Iâ€™ll generate the complete code.");
};
</script>
</body>
</html>
